// Draw
    // Draw entire board
        // Draw row
            // Draw Cell
    // Draw board including piece
        // Put piece on board
        // Remove piece from board

// Find floating pieces after row deletion
    // Check for valid position
        // If not, return
    // Loop through row
        // Check whether cell already searched
        // Check whether cell empty
        // Check whether cell above is full
    // Recursively search for floating piece above
    // Check length of array of cells
    // (If not 0) Store in list of floatin pieces

// Recursively search for floating piece
    // Check for valid position
        // If not, return
    // Check whether current cell is full
    // (If y is below lowest row deleted) stop recursive function and clear piece
    // (If position valid and not already searched)
        // Add coord to piece
        // Recursively run function

// Cell -- extends Coords
    // Check validity
    // Set empty
    // Set full
    // Is empty
    // Is full

// Coords
    // getX
    // getY
    // sum
    // mutateSum

// Playfield
    // Constructor
        // Set width and height
    // Getter
        // Get width
        // Get cells
        // Get cell
        // Get cell row
    // Test
        // Row is full
        // Row is empty
    // Setter
        // Create empty field
        // Fill cells
        // Empty cells
        // Clone one row to another
        // Create empty row
        // Delete row
            // Get lowest row to be deleted
            // (If row needed to be deleted)
            // While loop -- while row not empty and not at top of play field
                // While loop -- look upward to find adjacent full rows
                    // Remember how many rows are being deleted
                // End of loop -- swap rows down by the number of rows to be deleted
            // End of loop
            // create new empty rows above top-most row swapped downward

// BoundsTester
    // Check whether value is between min and max

// NoOverlap
    // Takes Coords[]
        // if any cells are valid cells and full
            // return false
        // else return true

// NoOverlapCoords
    // Takes Coords
        // return -- cell isn'tester valid or cell isn'tester full

// XBoundsTester
    // setWidth
    // apply (Coords and int)
    // applyArray (Coords[])

// YBoundsTester
    // setHeight
    // apply (Coords and int)
    // applyNoMin (ignore top of playfield)
    // applyArrayNoMin

// Kick & KickIPiece
    // Loop through given possibilities and accept first available

// Rotate
    // Increment orientation by given value, depending on max and wrap if necessary

// Shift
    // Increment orientation by given value

// Get piece insertion coordinates
    // Get piece size
    // Get center
    // Get shape (relative coordinate template)
    // Apply relative coordinates to center

// TetrisPiece
    // Stores positional and historical data
    // Getter
        // Clone
        // Get tetromino
        // Get Kick
        // Get orientation
        // Get orientation max value
        // Get relative coordinates of tetromino
        // Get coordinates of piece on playField
        // Get center
        // Get previous orientation
    // Setter
        // Randomly set new shape/tetromino and move center to default position
        // Set tetromino
        // Reset tetromino and orientation -- not position
        // Set orientation
        // Set center
    // Test
// Tetromino
    // Getter
        // Get relative coordinates by orientation
        // Get max number of orientations
        // Get piece size
        // Kick
// Game
    // Getter
        // Get currentPiece piece
        // Get width
        // Get height
        // Get sinking pieces
    // Setter
        // Reset current and next piece
        // Set next piece to currentPiece piece
        // Set currentPiece piece to a given TetrisPiece
        // Randomly set next piece
        // Add sinking piece
        // Remove sinking piece
        // Set sinking pieces
    // Test
        // Invalid position (TetrisPiece)
        // Invalid position (ArrayList<Coords>)
        // Invalid position (int, int)
        // Invalid position ()
        // Cell already searched
    // Side effect(?)
        // manipulate
        // manipulate rotate
        // drop sinking pieces
        // insert piece into board
            // fill cells
        // put piece on board (Coords[])
        // put piece on board (ArrayList<Coords>)
        // remove piece from board

// TurnLogic
    // Getters
    // Setters
    // Test
        // continue game
            // Set-up
                // Drop currentPiece piece
                // Test validity of position
                // Drop sinking pieces
                // Put sinking pieces on board
            // If currentPiece piece's position is valid
                // Put piece on board
                // Delete rows
                    // (Create sinking pieces)
                // Set next piece to currentPiece piece
                // If position still invalid
                    // End game
                // Reset next piece
                // Draw board
            // Else
                // Put currentPiece piece back where it was

            // Return true
                // To continue game

    // Side effects
        // Play Game
            // while continue game
                // keyboard input
    // Get Keyboard input
        // etc...

// Ideas
    // Make playfield available inside Cells and Coords as static variable
    // Make Piece type that is Array or ArrayList of Coords
    // Look below deleted row, not just above
        // Search for blocks all the way to lowest row
    // RelativeCoords type -- type for coords used for calculating Coords
    // Tetrominos extend TetrisPiece
    // Implement Random Generator